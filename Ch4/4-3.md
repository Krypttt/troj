# Online vs. Offline
## Online
> read the tag(1 byte), and precede to determine the length of the file so as to load the bytes precisely
## Offline
> read the whole source include the tag, the length, and the rest of the file

In the end, we're gonna use the online method of cource, yet doing so would add some difficulties to our testing process

To be more clear, we'll have to set both the server side and the client side ready to test the program, which would result in dragging the progress of the entire project

Thus, we'll need both the On and Off line to make our program not only compatible with socket but can be tested anytime we wish
We're using type as our keys here in the `readers`(note that everything in python is an object, which is hashable)
[See More](/definition.md#hashable)
```python3
def nbyte_to_int(source):
    read_bytes  = lambda d, s : (d[:s], d[s:])
    read_file   = lambda d, s : (d.read(s), d)
    read_socket = lambda d, s : (d.recv(s), d)
    readers = {bytes : read_bytes,                              #using type as keys
              io.IOBase : read_file,
              socket.socket : read_socket} 
    reader = readers[type(source)]
    size_info = {'B': 1, 'H': 2, 'L': 4, 'Q': 8}
    btag, source = reader(source, 1)
    tag = btag.decode('utf-8')

    if not tag in size_info:                                    #check if type's valid
        raise TypeError("Invalid Type: {}".format(type(tag)))

    size = size_info[tag]
    bnum, source = reader(source, size)

    return struct.unpack('!' + tag, bnum)[0], source
```
